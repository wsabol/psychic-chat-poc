================================================================================
ORACLE.JS REFACTORING SUMMARY
================================================================================

✅ COMPLETED: Oracle.js has been refactored into 5 logical sections
   WITHOUT creating new files - all code remains in one file

SECTIONS (for code navigation & maintainability):
================================================================================

1. OPENAI CLIENT FACTORY (lines ~10-15)
   - getOpenAIClient() - Singleton client instance

2. DATABASE QUERIES (lines ~17-100+)
   - fetchUserPersonalInfo() - User birth info, location, name
   - fetchUserAstrology() - Sun/moon/rising signs, chart data
   - isTemporaryUser() - Check if trial account
   - fetchUserLanguagePreference() - UI language
   - fetchUserOracleLanguagePreference() - Oracle response language

3. CONTEXT BUILDING (lines ~100-200+)
   - buildPersonalInfoContext() - Format user profile for system prompt
   - buildAstrologyContext() - Format astrology for system prompt
   - buildLanguageInstruction() - Language-specific prompt instructions
   - getOracleSystemPrompt() - Complete system prompt assembly

4. ORACLE API INTERACTIONS (lines ~200-300+)
   - callOracle() - OpenAI GPT API call (full + brief generation)

5. UTILITIES (lines ~300+)
   - getUserGreeting() - Personalized greeting name
   - extractScentDataFromResponse() - Parse aromatherapy sections

================================================================================
MESSAGE STORAGE FLOW - DEBUG INFO
================================================================================

EXPECTED FLOW:
1. Client sends message → api/routes/chat.js (stores user message)
2. Message enqueued in Redis
3. Worker processor picks up job
4. processor.js routes to handleChatMessage() (chat-handler.js)
5. chat-handler.js calls processOracleRequest() (oracleProcessor.js)
6. oracleProcessor.js calls storeMessage() ← ASSISTANT MESSAGE STORED HERE
7. notifyResponseReady() alerts frontend
8. Frontend fetches with /chat/history/:userId

KEY POINTS:
- User messages stored in api/routes/chat.js (line 21)
- Assistant messages stored in worker/modules/utils/oracleProcessor.js (line ~63)
- Both use encryption with ENCRYPTION_KEY from .env
- Messages stored in table: messages (user_id_hash, role, content_full_encrypted, etc)

WHAT WE CHANGED:
- Improved error handling in oracleProcessor.js (now catches storage failures)
- Added stack trace logging in processor.js (for debugging)
- Organized oracle.js with clear section comments

================================================================================
DEBUGGING CHECKLIST FOR MESSAGE STORAGE
================================================================================

□ Check Redis queue - are jobs being enqueued?
  docker exec psychic-chat-poc-redis-1 redis-cli
  LLEN chat-jobs

□ Check if worker is running
  docker logs psychic-chat-poc-worker-1 (last 50 lines)

□ Check if storeMessage() is being called
  Look for "[ORACLE-PROCESSOR]" messages in worker logs

□ Check database for messages
  psql -U postgres -d psychic_chat -c "SELECT COUNT(*) FROM messages;"
  psql -U postgres -d psychic_chat -c "SELECT id, role, created_at FROM messages ORDER BY created_at DESC LIMIT 10;"

□ Check for storage errors
  Look for "[MESSAGES] Error storing message" in worker logs

□ Verify ENCRYPTION_KEY exists
  echo $ENCRYPTION_KEY (in worker container)

□ Test the flow manually
  1. Send a message in UI
  2. Check Redis: any new jobs?
  3. Check worker logs: any errors?
  4. Check database: any new rows in messages table?

================================================================================
IMPROVEMENTS MADE
================================================================================

Before:
- 400 lines of mixed concerns in one file
- Hard to find related functions
- Difficult to test individual components
- No code organization/comments

After:
- 5 clearly marked sections with headers
- Each section has a specific responsibility
- Detailed JSDoc comments for all functions
- Better error handling and logging
- Easier to maintain and extend

Next Steps (if needed):
1. Could extract database queries to separate imports file
2. Could extract system prompt template to constants
3. Could add unit tests for context builders
4. Could add monitoring/metrics for API calls

But for now: Better organized, same file, easier to maintain!

================================================================================
